<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>1in2 Arena | Chicken League</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="security-bridge.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&family=Inter:wght@400;900&display=swap');
        body { background: #000; color: #fff; overflow: hidden; touch-action: none; font-family: 'Inter', sans-serif; }
        .brand-blue { color: #3b82f6; }
        .glass-ui { background: rgba(255, 255, 255, 0.03); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.08); }
        #arena-container { position: relative; width: 360px; height: 360px; margin: 0 auto; border-radius: 1.5rem; background: #050505; border: 1px solid #111; }
        #touch-mask { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; touch-action: none; }
        #grid-bg { position: absolute; display: grid; grid-template-columns: repeat(6, 60px); z-index: 1; }
        .grid-cell { width: 60px; height: 60px; border: 0.5px dotted rgba(255, 255, 255, 0.1); }
        .item { position: absolute; width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; font-size: 2rem; transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1); z-index: 10; pointer-events: none; }
        .match-vanish { transform: scale(0) !important; opacity: 0; }
        .score-box { border-left: 4px solid #3b82f6; }
        .timer-font { font-family: 'Orbitron', sans-serif; }
    </style>
</head>
<body class="flex flex-col items-center py-6">

    <div class="w-full max-w-md px-6 flex justify-between items-center mb-8">
        <div class="glass-ui p-4 rounded-2xl score-box">
            <p class="text-[9px] text-gray-400 font-black uppercase tracking-widest">Global Weight</p>
            <h2 id="score" class="text-3xl font-black text-white">0.0<span class="text-xs brand-blue ml-1">kg</span></h2>
        </div>
        <div class="text-right">
            <div id="countdown" class="text-2xl font-black brand-blue timer-font italic">OPEN</div>
            <p class="text-[8px] font-bold text-gray-500 uppercase">Arena Window</p>
        </div>
    </div>

    <div id="arena-container">
        <div id="grid-bg"></div>
        <div id="item-layer"></div>
        <div id="touch-mask"></div> 
    </div>

    <div class="mt-8 glass-ui px-8 py-3 rounded-full flex items-center gap-3">
        <div id="heartbeat-led" class="h-2 w-2 bg-blue-600 rounded-full animate-pulse shadow-[0_0_10px_#3b82f6]"></div>
        <span id="player-tag" class="text-[9px] font-black uppercase tracking-[0.2em]">Linking to Registry...</span>
    </div>

    <script>
        const items = ['ðŸŒ½', 'ðŸ—', 'ðŸ¥š', 'ðŸ”', 'ðŸŒ¾'];
        const rows = 6, cols = 6, size = 60;
        let board = [], currentSessionScore = 0, dbBaseScore = 0, isProcessing = false;
        let startR, startC, startX, startY, currentUser, heartbeat;

        const itemLayer = document.getElementById('item-layer');
        const touchMask = document.getElementById('touch-mask');

        async function startArenaLogic() {
            const { data: { session } } = await sb.auth.getSession();
            if (!session) { window.location.href = "login.html"; return; }
            
            currentUser = session.user.user_metadata.username;
            document.getElementById('player-tag').innerText = `Sync: ${currentUser}`;

            // Fetch initial DB score
            const { data } = await sb.from('league_performances').select('score').eq('username', currentUser).eq('league_id', '1in2').single();
            dbBaseScore = data ? data.score : 0;
            updateScoreDisplay();

            init(); 
            startHeartbeat();
        }

        function startHeartbeat() {
            heartbeat = setInterval(async () => {
                const { data: registry } = await sb.from('Leagues_Registry').select('*').eq('id', '1in2').single();
                const now = new Date();
                const closing = new Date(registry.closing_time);

                // Authority Check: If closed or inactive, boot user
                if (!registry.is_active || now > closing) {
                    clearInterval(heartbeat);
                    isProcessing = true;
                    alert("ARENA WINDOW CLOSED.");
                    window.location.href = '1in2leaderboard.html';
                } else {
                    // Update countdown display
                    const diff = closing - now;
                    const m = Math.floor(diff / 60000);
                    const s = Math.floor((diff % 60000) / 1000);
                    document.getElementById('countdown').innerText = `${m}:${s.toString().padStart(2, '0')}`;
                }
            }, 5000);
        }

        async function syncMatchToDB(weight) {
            // Real-time Push to Counter
            const { error } = await sb.rpc('increment_league_score', { 
                p_username: currentUser, 
                p_league_id: '1in2', 
                p_weight: weight 
            });
            if (!error) {
                dbBaseScore += weight;
                updateScoreDisplay();
            }
        }

        function updateScoreDisplay() {
            document.getElementById('score').innerHTML = `${dbBaseScore.toFixed(1)}<span class="text-xs brand-blue ml-1">kg</span>`;
        }

        function init() {
            const gridBg = document.getElementById('grid-bg');
            gridBg.innerHTML = '';
            for (let i = 0; i < 36; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                gridBg.appendChild(cell);
            }
            for (let r = 0; r < rows; r++) {
                board[r] = [];
                for (let c = 0; c < cols; c++) { spawnItem(r, c); }
            }
            setTimeout(checkMatches, 500);
        }

        function spawnItem(r, c) {
            const type = items[Math.floor(Math.random() * items.length)];
            const el = document.createElement('div');
            el.className = 'item';
            el.innerHTML = type;
            el.style.transform = `translate(${c * size}px, ${r * size}px)`;
            itemLayer.appendChild(el);
            board[r][c] = { type, el };
        }

        // ... [Keeping your existing touch handling logic: touchstart, touchend, trySwap] ...
        touchMask.addEventListener('touchstart', (e) => {
            if (isProcessing) return;
            const rect = touchMask.getBoundingClientRect();
            startX = e.touches[0].clientX - rect.left;
            startY = e.touches[0].clientY - rect.top;
            startC = Math.floor(startX / size);
            startR = Math.floor(startY / size);
        });

        touchMask.addEventListener('touchend', (e) => {
            if (isProcessing || startR === undefined) return;
            const rect = touchMask.getBoundingClientRect();
            const endX = e.changedTouches[0].clientX - rect.left;
            const endY = e.changedTouches[0].clientY - rect.top;
            const dx = endX - startX, dy = endY - startY;
            const threshold = 25;
            let tr = startR, tc = startC;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (Math.abs(dx) > threshold) tc += dx > 0 ? 1 : -1;
            } else {
                if (Math.abs(dy) > threshold) tr += dy > 0 ? 1 : -1;
            }
            if (tr >= 0 && tr < rows && tc >= 0 && tc < cols && (tr !== startR || tc !== startC)) {
                trySwap(startR, startC, tr, tc);
            }
            startR = undefined;
        });

        function trySwap(r1, c1, r2, c2) {
            isProcessing = true;
            const item1 = board[r1][c1];
            const item2 = board[r2][c2];
            item1.el.style.transform = `translate(${c2 * size}px, ${r2 * size}px)`;
            item2.el.style.transform = `translate(${c1 * size}px, ${r1 * size}px)`;
            board[r1][c1] = item2;
            board[r2][c2] = item1;
            setTimeout(() => {
                if (!checkMatches()) {
                    item1.el.style.transform = `translate(${c1 * size}px, ${r1 * size}px)`;
                    item2.el.style.transform = `translate(${c2 * size}px, ${r2 * size}px)`;
                    board[r1][c1] = item1;
                    board[r2][c2] = item2;
                    setTimeout(() => { isProcessing = false; }, 250);
                } else {
                    isProcessing = false;
                }
            }, 300);
        }

        function checkMatches() {
            let matches = new Set();
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols - 2; c++) {
                    if (board[r][c] && board[r][c+1] && board[r][c+2] &&
                        board[r][c].type === board[r][c+1].type && board[r][c].type === board[r][c+2].type) {
                        matches.add(`${r},${c}`); matches.add(`${r},${c+1}`); matches.add(`${r},${c+2}`);
                    }
                }
            }
            for (let c = 0; c < cols; c++) {
                for (let r = 0; r < rows - 2; r++) {
                    if (board[r][c] && board[r+1][c] && board[r+2][c] &&
                        board[r][c].type === board[r+1][c].type && board[r][c].type === board[r+2][c].type) {
                        matches.add(`${r},${c}`); matches.add(`${r+1},${c}`); matches.add(`${r+2},${c}`);
                    }
                }
            }
            if (matches.size > 0) {
                isProcessing = true;
                const matchWeight = (matches.size * 0.1);
                
                // REAL-TIME SYNC:
                syncMatchToDB(matchWeight);

                matches.forEach(coord => {
                    const [r, c] = coord.split(',').map(Number);
                    if(board[r][c]) {
                        board[r][c].el.classList.add('match-vanish');
                        const el = board[r][c].el;
                        setTimeout(() => el.remove(), 250);
                        board[r][c] = null;
                    }
                });
                setTimeout(applyGravity, 300);
                return true;
            }
            return false;
        }

        function applyGravity() {
            for (let c = 0; c < cols; c++) {
                let empty = 0;
                for (let r = rows - 1; r >= 0; r--) {
                    if (board[r][c] === null) empty++;
                    else if (empty > 0) {
                        const item = board[r][c];
                        board[r + empty][c] = item;
                        board[r][c] = null;
                        item.el.style.transform = `translate(${c * size}px, ${(r + empty) * size}px)`;
                    }
                }
                for (let i = 0; i < empty; i++) {
                    const r = i;
                    const type = items[Math.floor(Math.random() * items.length)];
                    const el = document.createElement('div');
                    el.className = 'item';
                    el.innerHTML = type;
                    el.style.transform = `translate(${c * size}px, -60px)`;
                    itemLayer.appendChild(el);
                    board[r][c] = { type, el };
                    setTimeout(() => { el.style.transform = `translate(${c * size}px, ${r * size}px)`; }, 50);
                }
            }
            setTimeout(() => { if (!checkMatches()) isProcessing = false; }, 450);
        }

        startArenaLogic();
    </script>
</body>
</html>
