<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>1in2 Arena | Chicken League</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <script src="security-bridge.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&family=Inter:wght@400;900&display=swap');
        body { background: #000; color: #fff; overflow: hidden; touch-action: none; font-family: 'Inter', sans-serif; }
        .brand-red { color: #ff0000; }
        .glass-ui { background: rgba(255, 255, 255, 0.03); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.08); }
        #arena-container { position: relative; width: 360px; height: 360px; margin: 0 auto; border-radius: 1.5rem; background: #050505; border: 1px solid #111; }
        #touch-mask { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; touch-action: none; }
        #grid-bg { position: absolute; display: grid; grid-template-columns: repeat(6, 60px); z-index: 1; }
        .grid-cell { width: 60px; height: 60px; border: 0.5px dotted rgba(255, 255, 255, 0.1); }
        .item { position: absolute; width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; font-size: 2rem; transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1); z-index: 10; pointer-events: none; }
        .match-vanish { transform: scale(0) !important; opacity: 0; }
        .score-box { border-left: 4px solid #ff0000; }
        .timer-font { font-family: 'Orbitron', sans-serif; }
    </style>
</head>
<body class="flex flex-col items-center py-6">

    <div class="w-full max-w-md px-6 flex justify-between items-center mb-8">
        <div class="glass-ui p-4 rounded-2xl score-box">
            <p class="text-[9px] text-gray-400 font-black uppercase tracking-widest">Growth Weight</p>
            <h2 id="score" class="text-3xl font-black text-white">0.0<span class="text-xs brand-red ml-1">kg</span></h2>
        </div>
        <div class="flex-1 flex justify-center px-2">
            <button onclick="location.href='1in2leaderboard.html'" style="z-index: 101;" class="bg-white text-black text-[8px] font-black uppercase tracking-tighter px-3 py-2 rounded-md border border-white hover:bg-red-600 hover:text-white hover:border-red-600 transition-all shadow-[0_0_10px_rgba(255,255,255,0.1)]">View Leader Board</button>
        </div>
        <div class="text-center">
            <div id="timer" class="text-4xl font-black brand-red timer-font italic">60</div>
            <p class="text-[8px] font-bold text-gray-500 uppercase">Seconds</p>
        </div>
    </div>

    <div id="arena-container">
        <div id="grid-bg"></div>
        <div id="item-layer"></div>
        <div id="touch-mask"></div> 
    </div>

    <div class="mt-8 glass-ui px-8 py-3 rounded-full flex items-center gap-3">
        <div class="h-2 w-2 bg-red-600 rounded-full animate-pulse shadow-[0_0_10px_red]"></div>
        <span id="player-tag" class="text-[9px] font-black uppercase tracking-[0.2em]">Authenticating...</span>
    </div>

    <script>
        const items = ['üåΩ', 'üçó', 'ü•ö', 'üêî', 'üåæ'];
        const rows = 6, cols = 6, size = 60;
        let board = [], score = 0, timeLeft = 60, isProcessing = false;
        let startR, startC, startX, startY;

        const itemLayer = document.getElementById('item-layer');
        const touchMask = document.getElementById('touch-mask');

        // THE COMMAND CENTER: Wait for Auth before starting game
        async function startArenaLogic() {
            const { data: { session } } = await sb.auth.getSession();
            if (session) {
                const username = session.user.user_metadata.username || "Elite_Chicken";
                document.getElementById('player-tag').innerText = `Active: ${username}`;
                console.log("ARENA START: Identity Verified.");
                init(); // Start the grid
            } else {
                window.location.href = "login.html";
            }
        }

        function init() {
            const gridBg = document.getElementById('grid-bg');
            gridBg.innerHTML = ''; // Clear pitch
            for (let i = 0; i < 36; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                gridBg.appendChild(cell);
            }

            for (let r = 0; r < rows; r++) {
                board[r] = [];
                for (let c = 0; c < cols; c++) {
                    spawnItem(r, c);
                }
            }
            startTimer();
            setTimeout(checkMatches, 500);
        }

        function spawnItem(r, c) {
            const type = items[Math.floor(Math.random() * items.length)];
            const el = document.createElement('div');
            el.className = 'item';
            el.innerHTML = type;
            el.style.transform = `translate(${c * size}px, ${r * size}px)`;
            itemLayer.appendChild(el);
            board[r][c] = { type, el };
        }

        touchMask.addEventListener('touchstart', (e) => {
            if (isProcessing) return;
            const rect = touchMask.getBoundingClientRect();
            startX = e.touches[0].clientX - rect.left;
            startY = e.touches[0].clientY - rect.top;
            startC = Math.floor(startX / size);
            startR = Math.floor(startY / size);
        });

        touchMask.addEventListener('touchend', (e) => {
            if (isProcessing || startR === undefined) return;
            const rect = touchMask.getBoundingClientRect();
            const endX = e.changedTouches[0].clientX - rect.left;
            const endY = e.changedTouches[0].clientY - rect.top;
            const dx = endX - startX, dy = endY - startY;
            const threshold = 25;
            let tr = startR, tc = startC;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (Math.abs(dx) > threshold) tc += dx > 0 ? 1 : -1;
            } else {
                if (Math.abs(dy) > threshold) tr += dy > 0 ? 1 : -1;
            }
            if (tr >= 0 && tr < rows && tc >= 0 && tc < cols && (tr !== startR || tc !== startC)) {
                trySwap(startR, startC, tr, tc);
            }
            startR = undefined;
        });

        function trySwap(r1, c1, r2, c2) {
            isProcessing = true;
            const item1 = board[r1][c1];
            const item2 = board[r2][c2];
            item1.el.style.transform = `translate(${c2 * size}px, ${r2 * size}px)`;
            item2.el.style.transform = `translate(${c1 * size}px, ${r1 * size}px)`;
            board[r1][c1] = item2;
            board[r2][c2] = item1;
            setTimeout(() => {
                if (!checkMatches()) {
                    item1.el.style.transform = `translate(${c1 * size}px, ${r1 * size}px)`;
                    item2.el.style.transform = `translate(${c2 * size}px, ${r2 * size}px)`;
                    board[r1][c1] = item1;
                    board[r2][c2] = item2;
                    setTimeout(() => { isProcessing = false; }, 250);
                } else {
                    isProcessing = false;
                }
            }, 300);
        }

        function checkMatches() {
            let matches = new Set();
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols - 2; c++) {
                    if (board[r][c] && board[r][c+1] && board[r][c+2] &&
                        board[r][c].type === board[r][c+1].type && board[r][c].type === board[r][c+2].type) {
                        matches.add(`${r},${c}`); matches.add(`${r},${c+1}`); matches.add(`${r},${c+2}`);
                    }
                }
            }
            for (let c = 0; c < cols; c++) {
                for (let r = 0; r < rows - 2; r++) {
                    if (board[r][c] && board[r+1][c] && board[r+2][c] &&
                        board[r][c].type === board[r+1][c].type && board[r][c].type === board[r+2][c].type) {
                        matches.add(`${r},${c}`); matches.add(`${r+1},${c}`); matches.add(`${r+2},${c}`);
                    }
                }
            }
            if (matches.size > 0) {
                isProcessing = true;
                score += (matches.size * 0.1);
                document.getElementById('score').innerText = score.toFixed(1) + 'kg';
                matches.forEach(coord => {
                    const [r, c] = coord.split(',').map(Number);
                    if(board[r][c]) {
                        board[r][c].el.classList.add('match-vanish');
                        const el = board[r][c].el;
                        setTimeout(() => el.remove(), 250);
                        board[r][c] = null;
                    }
                });
                setTimeout(applyGravity, 300);
                return true;
            }
            return false;
        }

        function applyGravity() {
            for (let c = 0; c < cols; c++) {
                let empty = 0;
                for (let r = rows - 1; r >= 0; r--) {
                    if (board[r][c] === null) empty++;
                    else if (empty > 0) {
                        const item = board[r][c];
                        board[r + empty][c] = item;
                        board[r][c] = null;
                        item.el.style.transform = `translate(${c * size}px, ${(r + empty) * size}px)`;
                    }
                }
                for (let i = 0; i < empty; i++) {
                    const r = i;
                    const type = items[Math.floor(Math.random() * items.length)];
                    const el = document.createElement('div');
                    el.className = 'item';
                    el.innerHTML = type;
                    el.style.transform = `translate(${c * size}px, -60px)`;
                    itemLayer.appendChild(el);
                    board[r][c] = { type, el };
                    setTimeout(() => { el.style.transform = `translate(${c * size}px, ${r * size}px)`; }, 50);
                }
            }
            setTimeout(() => { if (!checkMatches()) isProcessing = false; }, 450);
        }

        function startTimer() {
            const int = setInterval(async () => {
                timeLeft--;
                document.getElementById('timer').innerText = timeLeft;
                if (timeLeft <= 0) { 
                    clearInterval(int); 
                    isProcessing = true; 
                    await saveGamePerformance(); 
                }
            }, 1000);
        }

        async function saveGamePerformance() {
            try {
                const { data: { user } } = await sb.auth.getUser();
                const activeUsername = user?.user_metadata?.username || "Elite_Chicken";
                await sb.from('league_performances').insert([{ 
                    username: activeUsername, 
                    score: parseFloat(score.toFixed(1)), 
                    league_id: '1in2' 
                }]);
                window.location.href = '1in2leaderboard.html';
            } catch (err) {
                window.location.href = '1in2leaderboard.html';
            }
        }

        // ENTRY POINT
        startArenaLogic();
    </script>
</body>
</html>
