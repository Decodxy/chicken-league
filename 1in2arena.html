<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>1in2 Arena | Chicken League</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&family=Inter:wght@400;900&display=swap');
        
        body { background: #000; color: #fff; overflow: hidden; touch-action: none; font-family: 'Inter', sans-serif; }
        .brand-red { color: #ff0000; }
        .glass-ui { background: rgba(255, 255, 255, 0.03); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.08); }
        
        #game-board { 
            position: relative;
            width: 360px; 
            height: 360px; 
            background: #050505;
            border-radius: 2rem;
            margin: 0 auto;
            border: 1px solid #111;
            overflow: hidden;
        }

        .item {
            position: absolute;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.2s;
            cursor: pointer;
            z-index: 10;
        }

        .match-vanish { transform: scale(0) !important; opacity: 0; }
        
        .score-box { border-left: 4px solid #ff0000; }
        .timer-font { font-family: 'Orbitron', sans-serif; }
    </style>
</head>
<body class="flex flex-col items-center py-6">

    <div class="w-full max-w-md px-6 flex justify-between items-center mb-10">
        <div class="glass-ui p-4 rounded-2xl score-box">
            <p class="text-[9px] text-gray-400 font-black uppercase tracking-widest">Live Weight</p>
            <h2 id="score" class="text-3xl font-black text-white">0.0<span class="text-xs brand-red ml-1">kg</span></h2>
        </div>
        <div class="text-center">
            <div id="timer" class="text-4xl font-black brand-red timer-font italic">60</div>
            <p class="text-[8px] font-bold text-gray-500 uppercase">Sec</p>
        </div>
    </div>

    <div id="game-board" class="glass-ui"></div>

    <div class="mt-12 glass-ui px-8 py-3 rounded-full flex items-center gap-3">
        <div class="h-2 w-2 bg-red-600 rounded-full animate-pulse"></div>
        <span class="text-[9px] font-black uppercase tracking-[0.2em]">Manual Swipe Precision</span>
    </div>

    <script>
        const items = ['üåΩ', 'üçó', 'ü•ö', 'üêî', 'üåæ'];
        const rows = 6, cols = 6, size = 60;
        let board = [], score = 0, timeLeft = 60;
        let startX, startY, isDragging = false, activeItem = null;

        const container = document.getElementById('game-board');

        function init() {
            for (let r = 0; r < rows; r++) {
                board[r] = [];
                for (let c = 0; c < cols; c++) {
                    spawnItem(r, c);
                }
            }
            startTimer();
            setTimeout(checkMatches, 600);
        }

        function spawnItem(r, c) {
            const type = items[Math.floor(Math.random() * items.length)];
            const el = document.createElement('div');
            el.className = 'item';
            el.innerHTML = type;
            el.style.transform = `translate(${c * size}px, ${r * size}px)`;
            
            el.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                activeItem = { r, c, el };
                isDragging = true;
            });

            container.appendChild(el);
            board[r][c] = { type, el };
        }

        document.addEventListener('touchend', (e) => {
            if (!isDragging || !activeItem) return;
            const endX = e.changedTouches[0].clientX;
            const endY = e.changedTouches[0].clientY;
            const dx = endX - startX, dy = endY - startY;
            const threshold = 30;

            let tr = activeItem.r, tc = activeItem.c;

            if (Math.abs(dx) > Math.abs(dy)) {
                if (Math.abs(dx) > threshold) tc += dx > 0 ? 1 : -1;
            } else {
                if (Math.abs(dy) > threshold) tr += dy > 0 ? 1 : -1;
            }

            if (tr >= 0 && tr < rows && tc >= 0 && tc < cols && (tr !== activeItem.r || tc !== activeItem.c)) {
                swap(activeItem.r, activeItem.c, tr, tc);
            }
            isDragging = false;
        });

        function swap(r1, c1, r2, c2, callback) {
            const item1 = board[r1][c1];
            const item2 = board[r2][c2];

            // Physical Slide Animation
            item1.el.style.transform = `translate(${c2 * size}px, ${r2 * size}px)`;
            item2.el.style.transform = `translate(${c1 * size}px, ${r1 * size}px)`;

            board[r1][c1] = item2;
            board[r2][c2] = item1;

            setTimeout(() => {
                if (!checkMatches() && !callback) {
                    // Undo Swap Slide
                    swap(r2, c2, r1, c1, true);
                }
            }, 350);
        }

        function checkMatches() {
            let toRemove = new Set();

            // Horiz
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols - 2; c++) {
                    if (board[r][c] && board[r][c+1] && board[r][c+2] &&
                        board[r][c].type === board[r][c+1].type && board[r][c].type === board[r][c+2].type) {
                        toRemove.add(`${r},${c}`); toRemove.add(`${r},${c+1}`); toRemove.add(`${r},${c+2}`);
                    }
                }
            }
            // Vert
            for (let c = 0; c < cols; c++) {
                for (let r = 0; r < rows - 2; r++) {
                    if (board[r][c] && board[r+1][c] && board[r+2][c] &&
                        board[r][c].type === board[r+1][c].type && board[r][c].type === board[r+2][c].type) {
                        toRemove.add(`${r},${c}`); toRemove.add(`${r+1},${c}`); toRemove.add(`${r+2},${c}`);
                    }
                }
            }

            if (toRemove.size > 0) {
                score += (toRemove.size * 0.1);
                document.getElementById('score').innerText = score.toFixed(1) + 'kg';
                toRemove.forEach(coord => {
                    const [r, c] = coord.split(',').map(Number);
                    board[r][c].el.classList.add('match-vanish');
                    setTimeout(() => board[r][c].el.remove(), 300);
                    board[r][c] = null;
                });
                setTimeout(applyGravity, 400);
                return true;
            }
            return false;
        }

        function applyGravity() {
            for (let c = 0; c < cols; c++) {
                let empty = 0;
                for (let r = rows - 1; r >= 0; r--) {
                    if (board[r][c] === null) {
                        empty++;
                    } else if (empty > 0) {
                        const item = board[r][c];
                        board[r + empty][c] = item;
                        board[r][c] = null;
                        // Gravity Slide Animation
                        item.el.style.transform = `translate(${c * size}px, ${(r + empty) * size}px)`;
                    }
                }
                // Fill top with sliding new items
                for (let i = 0; i < empty; i++) {
                    const r = i;
                    const type = items[Math.floor(Math.random() * items.length)];
                    const el = document.createElement('div');
                    el.className = 'item';
                    el.innerHTML = type;
                    // Start above board
                    el.style.transform = `translate(${c * size}px, -60px)`;
                    container.appendChild(el);
                    board[r][c] = { type, el };
                    // Trigger slide down
                    setTimeout(() => {
                        el.style.transform = `translate(${c * size}px, ${r * size}px)`;
                    }, 50);
                    
                    // Re-bind touch for new items
                    el.addEventListener('touchstart', (e) => {
                        startX = e.touches[0].clientX; startY = e.touches[0].clientY;
                        activeItem = { r, c, el }; isDragging = true;
                    });
                }
            }
            setTimeout(checkMatches, 500);
        }

        function startTimer() {
            const int = setInterval(() => {
                timeLeft--;
                document.getElementById('timer').innerText = timeLeft;
                if (timeLeft <= 0) { clearInterval(int); alert("Weight achieved: " + score.toFixed(1) + "kg"); }
            }, 1000);
        }

        init();
    </script>
</body>
</html>
